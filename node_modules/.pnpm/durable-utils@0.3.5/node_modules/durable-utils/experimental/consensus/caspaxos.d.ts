import { DurableObjectNamespace, Rpc } from "@cloudflare/workers-types";
export interface KV {
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T): Promise<T>;
    update<T>(key: string, updateFn: (currentValue: T | null) => T): Promise<T>;
    delete(key: string): Promise<boolean>;
    compareAndSet<T>(key: string, expected: T | null, newValue: T): Promise<T | null>;
}
export type Topology = {
    type: "locationHintWeighted";
    locations: Partial<Record<DurableObjectLocationHint, number>>;
};
export interface CASPaxosKVOptions {
    topology: Topology;
    clusterName: string;
}
export declare class CASPaxosKV<T extends Rpc.DurableObjectBranded | undefined> implements KV {
    #private;
    constructor(doNamespace: DurableObjectNamespace<T>, options: CASPaxosKVOptions);
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T): Promise<T>;
    update<T>(key: string, updateFn: (currentValue: T | null) => T): Promise<T>;
    compareAndSet<T>(key: string, expected: T | null, newValue: T): Promise<T | null>;
    delete(key: string): Promise<boolean>;
}
export type BallotNumber = {
    counter: number;
    id: string;
};
export type PrepareResult = {
    isPrepared: true;
    isConflict?: false;
    ballot: BallotNumber;
    value: any | null;
} | {
    isPrepared: false;
    isConflict: true;
    ballot: BallotNumber;
};
export type AcceptResult = {
    isOk: true;
    isConflict?: false;
    ballot: BallotNumber;
} | {
    isOk: false;
    isConflict: true;
    ballot: BallotNumber;
};
export interface PrepareNode {
    prepare(key: string, proposedBallot: BallotNumber, extra?: any): Promise<PrepareResult>;
}
export interface AcceptNode {
    accept(key: string, ballot: BallotNumber, value: any, promiseBallot: BallotNumber, extra?: any): Promise<AcceptResult>;
}
type NodeGroup<T> = {
    nodes: T[];
    quorum: number;
};
export declare class Proposer {
    private ballot;
    private prepare;
    private accept;
    private cache;
    private locks;
    constructor(ballot: BallotNumber, prepare: NodeGroup<PrepareNode>, accept: NodeGroup<AcceptNode>);
    change<T>(key: string, update: (curr: T | null) => T, extra?: any): Promise<T>;
    guessValue<T>(key: string, extra?: any): Promise<[BallotNumber, T | null]>;
    commitValue<T>(key: string, ballot: BallotNumber, value: T | null, promise: BallotNumber, extra?: any): Promise<void>;
    private tryLock;
    private unlock;
}
export declare class AcceptorClient implements PrepareNode, AcceptNode {
    private storage;
    constructor(storage: DurableObjectStorage);
    prepare(key: string, proposedBallot: BallotNumber, extra?: any): Promise<PrepareResult>;
    accept(key: string, preparedBallot: BallotNumber, preparedValue: any, nextBallot: BallotNumber, extra?: any): Promise<AcceptResult>;
}
export {};
