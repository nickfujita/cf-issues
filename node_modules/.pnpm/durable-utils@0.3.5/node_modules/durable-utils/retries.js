"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/retries.ts
var retries_exports = {};
__export(retries_exports, {
  jitterBackoff: () => jitterBackoff,
  tryN: () => tryN,
  tryWhile: () => tryWhile
});
module.exports = __toCommonJS(retries_exports);
function jitterBackoff(attempt, baseDelayMs, maxDelayMs) {
  const attemptUpperBoundMs = Math.min(2 ** attempt * baseDelayMs, maxDelayMs);
  return Math.floor(Math.random() * attemptUpperBoundMs);
}
async function tryN(n, fn, optionsOrFunction, optionsOld) {
  if (n <= 0) {
    throw new Error("n must be greater than 0");
  }
  n = Math.floor(n);
  let options;
  if (typeof optionsOrFunction !== "function") {
    options = optionsOrFunction ?? {};
  } else {
    options = {
      ...optionsOld,
      isRetryable: optionsOrFunction
    };
  }
  return await tryWhile(
    fn,
    (err, nextAttempt) => {
      return nextAttempt <= n && (options.isRetryable?.(err, nextAttempt) ?? true);
    },
    options
  );
}
async function tryWhile(fn, isRetryable, options) {
  const baseDelayMs = Math.floor(options?.baseDelayMs ?? 100);
  const maxDelayMs = Math.floor(options?.maxDelayMs ?? 3e3);
  if (baseDelayMs <= 0 || maxDelayMs <= 0) {
    throw new Error("baseDelayMs and maxDelayMs must be greater than 0");
  }
  if (baseDelayMs >= maxDelayMs) {
    throw new Error("baseDelayMs must be less than maxDelayMs");
  }
  let attempt = 1;
  while (true) {
    try {
      return await fn(attempt);
    } catch (err) {
      if (options?.verbose) {
        console.info({
          message: "tryWhile",
          attempt,
          error: String(err),
          errorProps: err
        });
      }
      attempt += 1;
      if (!isRetryable(err, attempt)) {
        throw err;
      }
      const delay = jitterBackoff(attempt, baseDelayMs, maxDelayMs);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  jitterBackoff,
  tryN,
  tryWhile
});
